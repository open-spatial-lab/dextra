{"version":3,"file":"flow-c8c2a53c.js","sources":["../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","../../node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js","../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js","../../node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["export class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _ET;\nlet ET;\nexport default async function EventTarget() {\n    return ET || init();\n}\nasync function init() {\n    _ET = window.EventTarget;\n    try {\n        new _ET();\n    }\n    catch {\n        _ET = (await import('event-target-shim')).EventTarget;\n    }\n    return (ET = _ET);\n}\n//# sourceMappingURL=EventTarget.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._emitUnpinned();\n            this._pin = null;\n        }\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _emitUnpinned() {\n        this.dispatchEvent(new CustomEvent('unpinned'));\n    }\n    _emitRange() {\n        const detail = {\n            first: this._first,\n            last: this._last,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        };\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        if (this._first !== -1 && this._last !== -1) {\n            const detail = new Map();\n            for (let idx = this._first; idx <= this._last; idx++) {\n                detail.set(idx, this._getItemPosition(idx));\n            }\n            this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n        }\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize, _firstVisible, _lastVisible } = this;\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        if (this._first !== _first ||\n            this._last !== _last ||\n            this._firstVisible !== _firstVisible ||\n            this._lastVisible !== _lastVisible) {\n            this._emitRange();\n        }\n        if (!(this._first === -1 && this._last === -1)) {\n            this._emitChildPositions();\n        }\n        if (this._scrollError !== 0) {\n            this._emitScrollError();\n        }\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map"],"names":["SizeCache","config","index","value","prev","average","_ET","ET","EventTarget","init","__vitePreload","dim1","direction","BaseLayout","Ctor","items","dir","dims","_viewDim1","_viewDim2","coords","oldPos","force","options","block","val","evt","type","listener","callback","lastScrollPosition","itemStartPosition","scrollPosition","itemSize","itemEndPosition","currentScrollPosition","detail","idx","min","max","firstVisible","lastVisible","flow","FlowLayout","leadingMargin","trailingMargin","offset","collapseMargins","a","b","m","MetricsCache","metrics","_a","_b","marginsToUpdate","key","k","sizes","c","delta","item","averageMarginSize","lower","upper","firstItem","lastItem","firstMin","candidateIdx","cMax","anchorSize","anchorLeadingMargin","anchorTrailingMargin","anchorErr","size","margin","pos","extentErr","_first","_last","_scrollSize","_firstVisible","_lastVisible"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}