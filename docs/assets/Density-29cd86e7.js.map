{"version":3,"file":"Density-29cd86e7.js","sources":["../../node_modules/d3-array/src/blur.js","../../node_modules/d3-array/src/nice.js","../../node_modules/d3-contour/src/array.js","../../node_modules/d3-contour/src/ascending.js","../../node_modules/d3-contour/src/area.js","../../node_modules/d3-contour/src/constant.js","../../node_modules/d3-contour/src/contains.js","../../node_modules/d3-contour/src/noop.js","../../node_modules/d3-contour/src/contours.js","../../node_modules/d3-contour/src/density.js","../../node_modules/@observablehq/plot/src/marks/density.js","../../dextra-components/src/components/marks/Density/src/Density.ts"],"sourcesContent":["export function blur(values, r) {\n  if (!((r = +r) >= 0)) throw new RangeError(\"invalid r\");\n  let length = values.length;\n  if (!((length = Math.floor(length)) >= 0)) throw new RangeError(\"invalid length\");\n  if (!length || !r) return values;\n  const blur = blurf(r);\n  const temp = values.slice();\n  blur(values, temp, 0, length, 1);\n  blur(temp, values, 0, length, 1);\n  blur(values, temp, 0, length, 1);\n  return values;\n}\n\nexport const blur2 = Blur2(blurf);\n\nexport const blurImage = Blur2(blurfImage);\n\nfunction Blur2(blur) {\n  return function(data, rx, ry = rx) {\n    if (!((rx = +rx) >= 0)) throw new RangeError(\"invalid rx\");\n    if (!((ry = +ry) >= 0)) throw new RangeError(\"invalid ry\");\n    let {data: values, width, height} = data;\n    if (!((width = Math.floor(width)) >= 0)) throw new RangeError(\"invalid width\");\n    if (!((height = Math.floor(height !== undefined ? height : values.length / width)) >= 0)) throw new RangeError(\"invalid height\");\n    if (!width || !height || (!rx && !ry)) return data;\n    const blurx = rx && blur(rx);\n    const blury = ry && blur(ry);\n    const temp = values.slice();\n    if (blurx && blury) {\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    } else if (blurx) {\n      blurh(blurx, values, temp, width, height);\n      blurh(blurx, temp, values, width, height);\n      blurh(blurx, values, temp, width, height);\n    } else if (blury) {\n      blurv(blury, values, temp, width, height);\n      blurv(blury, temp, values, width, height);\n      blurv(blury, values, temp, width, height);\n    }\n    return data;\n  };\n}\n\nfunction blurh(blur, T, S, w, h) {\n  for (let y = 0, n = w * h; y < n;) {\n    blur(T, S, y, y += w, 1);\n  }\n}\n\nfunction blurv(blur, T, S, w, h) {\n  for (let x = 0, n = w * h; x < w; ++x) {\n    blur(T, S, x, x + n, w);\n  }\n}\n\nfunction blurfImage(radius) {\n  const blur = blurf(radius);\n  return (T, S, start, stop, step) => {\n    start <<= 2, stop <<= 2, step <<= 2;\n    blur(T, S, start + 0, stop + 0, step);\n    blur(T, S, start + 1, stop + 1, step);\n    blur(T, S, start + 2, stop + 2, step);\n    blur(T, S, start + 3, stop + 3, step);\n  };\n}\n\n// Given a target array T, a source array S, sets each value T[i] to the average\n// of {S[i - r], …, S[i], …, S[i + r]}, where r = ⌊radius⌋, start <= i < stop,\n// for each i, i + step, i + 2 * step, etc., and where S[j] is clamped between\n// S[start] (inclusive) and S[stop] (exclusive). If the given radius is not an\n// integer, S[i - r - 1] and S[i + r + 1] are added to the sum, each weighted\n// according to r - ⌊radius⌋.\nfunction blurf(radius) {\n  const radius0 = Math.floor(radius);\n  if (radius0 === radius) return bluri(radius);\n  const t = radius - radius0;\n  const w = 2 * radius + 1;\n  return (T, S, start, stop, step) => { // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    let sum = radius0 * S[start];\n    const s0 = step * radius0;\n    const s1 = s0 + step;\n    for (let i = start, j = start + s0; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (let i = start, j = stop; i <= j; i += step) {\n      sum += S[Math.min(stop, i + s0)];\n      T[i] = (sum + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;\n      sum -= S[Math.max(start, i - s0)];\n    }\n  };\n}\n\n// Like blurf, but optimized for integer radius.\nfunction bluri(radius) {\n  const w = 2 * radius + 1;\n  return (T, S, start, stop, step) => { // stop must be aligned!\n    if (!((stop -= step) >= start)) return; // inclusive stop\n    let sum = radius * S[start];\n    const s = step * radius;\n    for (let i = start, j = start + s; i < j; i += step) {\n      sum += S[Math.min(stop, i)];\n    }\n    for (let i = start, j = stop; i <= j; i += step) {\n      sum += S[Math.min(stop, i + s)];\n      T[i] = sum / w;\n      sum -= S[Math.max(start, i - s)];\n    }\n  };\n}\n","import {tickIncrement} from \"./ticks.js\";\n\nexport default function nice(start, stop, count) {\n  let prestep;\n  while (true) {\n    const step = tickIncrement(start, stop, count);\n    if (step === prestep || step === 0 || !isFinite(step)) {\n      return [start, stop];\n    } else if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n    }\n    prestep = step;\n  }\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\n","export default function(a, b) {\n  return a - b;\n}\n","export default function(ring) {\n  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area;\n}\n","export default x => () => x;\n","export default function(ring, hole) {\n  var i = -1, n = hole.length, c;\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0], y = point[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;\n  }\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n","export default function() {}\n","import {extent, nice, thresholdSturges, ticks} from \"d3-array\";\nimport {slice} from \"./array.js\";\nimport ascending from \"./ascending.js\";\nimport area from \"./area.js\";\nimport constant from \"./constant.js\";\nimport contains from \"./contains.js\";\nimport noop from \"./noop.js\";\n\nvar cases = [\n  [],\n  [[[1.0, 1.5], [0.5, 1.0]]],\n  [[[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [0.5, 1.0]]],\n  [[[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 0.5], [1.0, 1.5]]],\n  [[[1.0, 0.5], [0.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 0.5]]],\n  [[[1.0, 1.5], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.5, 1.0]]],\n  [[[1.0, 1.5], [1.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 1.5]]],\n  []\n];\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      const e = extent(values, finite);\n      tz = ticks(...nice(e[0], e[1], tz), tz);\n      while (tz[tz.length - 1] >= e[1]) tz.pop();\n      while (tz[1] < e[0]) tz.shift();\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(value => contour(values, value));\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    const v = value == null ? NaN : +value;\n    if (isNaN(v)) throw new Error(`invalid value: ${value}`);\n\n    var polygons = [],\n        holes = [];\n\n    isorings(values, v, function(ring) {\n      smooth(ring, values, v);\n      if (area(ring) > 0) polygons.push([ring]);\n      else holes.push(ring);\n    });\n\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array,\n        fragmentByEnd = new Array,\n        x, y, t0, t1, t2, t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = above(values[0], value);\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = above(values[x + 1], value);\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = above(values[y * dx + dx], value);\n      t2 = above(values[y * dx], value);\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = above(values[y * dx + dx + x + 1], value);\n        t3 = t2, t2 = above(values[y * dx + x + 1], value);\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = above(values[y * dx + x + 1], value);\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function(point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v1 = valid(values[yt * dx + xt]);\n      if (x > 0 && x < dx && xt === x) {\n        point[0] = smooth1(x, valid(values[yt * dx + xt - 1]), v1, value);\n      }\n      if (y > 0 && y < dy && yt === y) {\n        point[1] = smooth1(y, valid(values[(yt - 1) * dx + xt]), v1, value);\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n\n// When computing the extent, ignore infinite values (as well as invalid ones).\nfunction finite(x) {\n  return isFinite(x) ? x : NaN;\n}\n\n// Is the (possibly invalid) x greater than or equal to the (known valid) value?\n// Treat any invalid value as below negative infinity.\nfunction above(x, value) {\n  return x == null ? false : +x >= value;\n}\n\n// During smoothing, treat any invalid value as negative infinity.\nfunction valid(v) {\n  return v == null || isNaN(v = +v) ? -Infinity : v;\n}\n\nfunction smooth1(x, v0, v1, value) {\n  const a = value - v0;\n  const b = v1 - v0;\n  const d = isFinite(a) || isFinite(b) ? a / b : Math.sign(a) / Math.sign(b);\n  return isNaN(d) ? x : x + d - 0.5;\n}\n","import {blur2, max, ticks} from \"d3-array\";\nimport {slice} from \"./array.js\";\nimport constant from \"./constant.js\";\nimport Contours from \"./contours.js\";\n\nfunction defaultX(d) {\n  return d[0];\n}\n\nfunction defaultY(d) {\n  return d[1];\n}\n\nfunction defaultWeight() {\n  return 1;\n}\n\nexport default function() {\n  var x = defaultX,\n      y = defaultY,\n      weight = defaultWeight,\n      dx = 960,\n      dy = 500,\n      r = 20, // blur radius\n      k = 2, // log2(grid cell size)\n      o = r * 3, // grid offset, to pad for blur\n      n = (dx + o * 2) >> k, // grid width\n      m = (dy + o * 2) >> k, // grid height\n      threshold = constant(20);\n\n  function grid(data) {\n    var values = new Float32Array(n * m),\n        pow2k = Math.pow(2, -k),\n        i = -1;\n\n    for (const d of data) {\n      var xi = (x(d, ++i, data) + o) * pow2k,\n          yi = (y(d, i, data) + o) * pow2k,\n          wi = +weight(d, i, data);\n      if (wi && xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        var x0 = Math.floor(xi),\n            y0 = Math.floor(yi),\n            xt = xi - x0 - 0.5,\n            yt = yi - y0 - 0.5;\n        values[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;\n        values[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;\n        values[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;\n        values[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;\n      }\n    }\n\n    blur2({data: values, width: n, height: m}, r * pow2k);\n    return values;\n  }\n\n  function density(data) {\n    var values = grid(data),\n        tz = threshold(values),\n        pow4k = Math.pow(2, 2 * k);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = ticks(Number.MIN_VALUE, max(values) / pow4k, tz);\n    }\n\n    return Contours()\n        .size([n, m])\n        .thresholds(tz.map(d => d * pow4k))\n      (values)\n        .map((c, i) => (c.value = +tz[i], transform(c)));\n  }\n\n  density.contours = function(data) {\n    var values = grid(data),\n        contours = Contours().size([n, m]),\n        pow4k = Math.pow(2, 2 * k),\n        contour = value => {\n          value = +value;\n          var c = transform(contours.contour(values, value * pow4k));\n          c.value = value; // preserve exact threshold value\n          return c;\n        };\n    Object.defineProperty(contour, \"max\", {get: () => max(values) / pow4k});\n    return contour;\n  };\n\n  function transform(geometry) {\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  }\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    coordinates.forEach(transformPoint);\n  }\n\n  // TODO Optimize.\n  function transformPoint(coordinates) {\n    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;\n    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;\n  }\n\n  function resize() {\n    o = r * 3;\n    n = (dx + o * 2) >> k;\n    m = (dy + o * 2) >> k;\n    return density;\n  }\n\n  density.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), density) : x;\n  };\n\n  density.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), density) : y;\n  };\n\n  density.weight = function(_) {\n    return arguments.length ? (weight = typeof _ === \"function\" ? _ : constant(+_), density) : weight;\n  };\n\n  density.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = +_[0], _1 = +_[1];\n    if (!(_0 >= 0 && _1 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, resize();\n  };\n\n  density.cellSize = function(_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) throw new Error(\"invalid cell size\");\n    return k = Math.floor(Math.log(_) / Math.LN2), resize();\n  };\n\n  density.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;\n  };\n\n  density.bandwidth = function(_) {\n    if (!arguments.length) return Math.sqrt(r * (r + 1));\n    if (!((_ = +_) >= 0)) throw new Error(\"invalid bandwidth\");\n    return r = (Math.sqrt(4 * _ * _ + 1) - 1) / 2, resize();\n  };\n\n  return density;\n}\n","import {contourDensity, geoPath} from \"d3\";\nimport {create} from \"../context.js\";\nimport {Mark} from \"../mark.js\";\nimport {TypedArray, coerceNumbers, maybeTuple, maybeZ} from \"../options.js\";\nimport {applyPosition} from \"../projection.js\";\nimport {\n  applyChannelStyles,\n  applyDirectStyles,\n  applyFrameAnchor,\n  applyIndirectStyles,\n  applyTransform,\n  groupZ\n} from \"../style.js\";\nimport {initializer} from \"../transforms/basic.js\";\n\nconst defaults = {\n  ariaLabel: \"density\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeMiterlimit: 1\n};\n\nexport class Density extends Mark {\n  constructor(data, {x, y, z, weight, fill, stroke, ...options} = {}) {\n    // If fill or stroke is specified as “density”, then temporarily treat these\n    // as a literal color when computing defaults and maybeZ; below, we’ll unset\n    // these constant colors back to undefined since they will instead be\n    // populated by a channel generated by the initializer.\n    const fillDensity = isDensity(fill) && ((fill = \"currentColor\"), true);\n    const strokeDensity = isDensity(stroke) && ((stroke = \"currentColor\"), true);\n    super(\n      data,\n      {\n        x: {value: x, scale: \"x\", optional: true},\n        y: {value: y, scale: \"y\", optional: true},\n        z: {value: maybeZ({z, fill, stroke}), optional: true},\n        weight: {value: weight, optional: true}\n      },\n      densityInitializer({...options, fill, stroke}, fillDensity, strokeDensity),\n      defaults\n    );\n    if (fillDensity) this.fill = undefined;\n    if (strokeDensity) this.stroke = undefined;\n    this.z = z;\n  }\n  filter(index) {\n    return index; // don’t filter contours constructed by initializer\n  }\n  render(index, scales, channels, dimensions, context) {\n    const {contours} = channels;\n    const path = geoPath();\n    return create(\"svg:g\", context)\n      .call(applyIndirectStyles, this, dimensions, context)\n      .call(applyTransform, this, {})\n      .call((g) =>\n        g\n          .selectAll()\n          .data(index)\n          .enter()\n          .append(\"path\")\n          .call(applyDirectStyles, this)\n          .call(applyChannelStyles, this, channels)\n          .attr(\"d\", (i) => path(contours[i]))\n      )\n      .node();\n  }\n}\n\nexport function density(data, {x, y, ...options} = {}) {\n  [x, y] = maybeTuple(x, y);\n  return new Density(data, {...options, x, y});\n}\n\nconst dropChannels = new Set([\"x\", \"y\", \"z\", \"weight\"]);\n\nfunction densityInitializer(options, fillDensity, strokeDensity) {\n  const k = 100; // arbitrary scale factor for readability\n  let {bandwidth, thresholds} = options;\n  bandwidth = bandwidth === undefined ? 20 : +bandwidth;\n  thresholds =\n    thresholds === undefined\n      ? 20\n      : typeof thresholds?.[Symbol.iterator] === \"function\"\n      ? coerceNumbers(thresholds)\n      : +thresholds;\n  return initializer(options, function (data, facets, channels, scales, dimensions, context) {\n    const W = channels.weight ? coerceNumbers(channels.weight.value) : null;\n    const Z = channels.z?.value;\n    const {z} = this;\n    const [cx, cy] = applyFrameAnchor(this, dimensions);\n    const {width, height} = dimensions;\n\n    // Get the (either scaled or projected) xy channels.\n    const {x: X, y: Y} = applyPosition(channels, scales, context);\n\n    // Group any of the input channels according to the first index associated\n    // with each z-series or facet. Drop any channels not be needed for\n    // rendering after the contours are computed.\n    const newChannels = Object.fromEntries(\n      Object.entries(channels)\n        .filter(([key]) => !dropChannels.has(key))\n        .map(([key, channel]) => [key, {...channel, value: []}])\n    );\n\n    // If the fill or stroke encodes density, construct new output channels.\n    const FD = fillDensity && [];\n    const SD = strokeDensity && [];\n\n    const density = contourDensity()\n      .x(X ? (i) => X[i] : cx)\n      .y(Y ? (i) => Y[i] : cy)\n      .weight(W ? (i) => W[i] : 1)\n      .size([width, height])\n      .bandwidth(bandwidth);\n\n    // Compute the grid for each facet-series.\n    const facetsContours = [];\n    for (const facet of facets) {\n      const facetContours = [];\n      facetsContours.push(facetContours);\n      for (const index of Z ? groupZ(facet, Z, z) : [facet]) {\n        const contour = density.contours(index);\n        facetContours.push([index, contour]);\n      }\n    }\n\n    // If explicit thresholds were not specified, find the maximum density of\n    // all grids and use this to compute thresholds.\n    let T = thresholds;\n    if (!(T instanceof TypedArray)) {\n      let maxValue = 0;\n      for (const facetContours of facetsContours) {\n        for (const [, contour] of facetContours) {\n          const max = contour.max;\n          if (max > maxValue) maxValue = max;\n        }\n      }\n      T = Float64Array.from({length: thresholds - 1}, (_, i) => (maxValue * k * (i + 1)) / thresholds);\n    }\n\n    // Generate contours for each facet-series.\n    const newFacets = [];\n    const contours = [];\n    for (const facetContours of facetsContours) {\n      const newFacet = [];\n      newFacets.push(newFacet);\n      for (const [index, contour] of facetContours) {\n        for (const t of T) {\n          newFacet.push(contours.length);\n          contours.push(contour(t / k));\n          if (FD) FD.push(t);\n          if (SD) SD.push(t);\n          for (const key in newChannels) {\n            newChannels[key].value.push(channels[key].value[index[0]]);\n          }\n        }\n      }\n    }\n\n    // If the fill or stroke encodes density, ensure that a zero value is\n    // included so that the default color scale domain starts at zero. Otherwise\n    // if the starting range value is the same as the background color, the\n    // first contour might not be visible.\n    if (FD) FD.push(0);\n    if (SD) SD.push(0);\n\n    return {\n      data,\n      facets: newFacets,\n      channels: {\n        ...newChannels,\n        ...(FD && {fill: {value: FD, scale: \"color\"}}),\n        ...(SD && {stroke: {value: SD, scale: \"color\"}}),\n        contours: {value: contours}\n      }\n    };\n  });\n}\n\nfunction isDensity(value) {\n  return /^density$/i.test(value);\n}\n","import { customElement, property } from \"lit/decorators.js\";\nimport { PlotMark } from \"../../PlotMark/src/PlotMark\";\nimport * as Plot from \"@observablehq/plot\";\nimport { safeCustomElement } from \"../../../core/decorators/safeCustomElement\";\n\n@safeCustomElement(\"osl-density-plot\")\nexport class OslPlotDensity extends PlotMark {\n  mark = \"density\"\n\n  @property({ type: String })\n  x?: string;\n\n  @property({ type: String })\n  y?: string;\n\n  @property({ type: Number })\n  bandwidth?: number;\n\n  markOptions: (keyof this)[] = ['x','y','bandwidth'];\n\n  connectedCallback(): void {\n    console.log('connected!')\n    console.log(this.allOptions)\n    super.connectedCallback();\n  }\n\n  public get plot() {\n    const innerData = this?.currentResults;\n    const options = this.allOptions;\n\n    return (overrideData?: any, overrideOptions?: {}) => {\n      const data = innerData?.length ? innerData : overrideData;\n      return Plot.density(data, { ...overrideOptions, ...options});\n    };\n  }\n\n  render() {\n    return null\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"osl-density-plot\": OslPlotDensity;\n  }\n}"],"names":["blur2","Blur2","blurf","blur","data","rx","ry","values","width","height","blurx","blury","temp","blurh","blurv","T","S","w","h","y","n","x","radius","radius0","bluri","t","start","stop","step","sum","s0","s1","i","j","s","nice","count","prestep","tickIncrement","array","slice","ascending","a","b","area","ring","constant","contains","hole","c","ringContains","point","pi","xi","yi","pj","xj","yj","segmentContains","collinear","within","p","q","r","noop","cases","contours","dx","dy","threshold","thresholdSturges","smooth","smoothLinear","tz","e","extent","finite","ticks","value","contour","v","polygons","holes","isorings","polygon","callback","fragmentByStart","fragmentByEnd","t0","t1","t2","t3","above","stitch","line","end","startIndex","index","endIndex","f","g","xt","yt","v1","valid","smooth1","_","_0","_1","v0","d","defaultX","defaultY","defaultWeight","contourDensity","weight","k","o","m","grid","pow2k","wi","x0","y0","density","pow4k","max","Contours","transform","geometry","transformPolygon","coordinates","transformRing","transformPoint","resize","defaults","Density","Mark","z","fill","stroke","options","fillDensity","isDensity","strokeDensity","maybeZ","densityInitializer","scales","channels","dimensions","context","path","geoPath","create","applyIndirectStyles","applyTransform","applyDirectStyles","applyChannelStyles","maybeTuple","dropChannels","bandwidth","thresholds","coerceNumbers","initializer","facets","W","Z","_a","cx","cy","applyFrameAnchor","X","Y","applyPosition","newChannels","key","channel","FD","SD","facetsContours","facet","facetContours","groupZ","TypedArray","maxValue","newFacets","newFacet","OslPlotDensity","PlotMark","innerData","overrideData","overrideOptions","Plot.density","__decorateClass","property","safeCustomElement"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10]}